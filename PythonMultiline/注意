线程在执行过程中与进程还是有区别的。每个独立的进程有一个程序的入口，顺序执行序列和程序的出口。但是线程不能独立执行，必须
依存于应用程序中，由应用程序提供多个线程的控制。
进程是资源分配的基本单位，将内存等资源分配给线程，每个线程都有自己的cpu寄存器等资源。指令指针和堆栈指针寄存器是线程资源中
最重要的两个寄存器。线程总是在进程中获取资源运行，这些指针寄存器都用于标志拥有线程的进程地址空间中的内存
线程可以被抢占中断
在其他线程正在运行时，线程可以暂时搁置，这就是线程的退让

1. 线程创建
通过class MyThread继承threading.Thread的方式，假如在子类MyThread中重写了run方法
那么对于用MyThread类创建的线程对象，在执行start()会自动执行run函数

另外一种创建线程的方法不通过类来包装线程对象，而是通过函数方法来创建线程
例如：thread.start_new_thread ( function, args[, kwargs] )，function为线程执行的函数，

2. 那么问题来了，假如用MyThread创建线程时，还指定了线程函数target=某个函数f
那么线程start的时候是先执行run函数还是县执行线程函数f
哈哈，这种情况一般时不会出现的，一般会将函数f作为被调用的函数添加到run函数中

3.一个进程中至少有一个线程，并作为程序的入口，这个线程一般是我们的主线程。程序运行时，我们可以在主线程中启动其他的线程
一个进程至少有一个主线程，其他为工作线程

4.start和run方法的区别
start()启动一个子线程，线程名即为定义的name
run()方法并不是启动一个新线程，就是在主线程中调用了一个普通函数
thread=myThread(1,"mythrd",1)
thread.run()
thread.start()
thread继承了threading.Thread类，并且重写了run方法
第一句thread=myThread(1,"mythrd",1)创建线程并不会自动去调用run方法
第二句thread.run()只是一个函数调用，在主线程中调用了run方法，并没有启动新线程
第三局thread.start()启动了创建的线程，线程start()后会自动调用run方法