线程在执行过程中与进程还是有区别的。每个独立的进程有一个程序的入口，顺序执行序列和程序的出口。但是线程不能独立执行，必须
依存于应用程序中，由应用程序提供多个线程的控制。
进程是资源分配的基本单位，将内存等资源分配给线程，每个线程都有自己的cpu寄存器等资源。指令指针和堆栈指针寄存器是线程资源中
最重要的两个寄存器。线程总是在进程中获取资源运行，这些指针寄存器都用于标志拥有线程的进程地址空间中的内存
线程可以被抢占中断
在其他线程正在运行时，线程可以暂时搁置，这就是线程的退让

1. 线程创建
通过class MyThread继承threading.Thread的方式，假如在子类MyThread中重写了run方法
那么对于用MyThread类创建的线程对象，在执行start()会自动执行run函数

另外一种创建线程的方法不通过类来包装线程对象，而是通过函数方法来创建线程
例如：thread.start_new_thread ( function, args[, kwargs] )，function为线程执行的函数，

2. 那么问题来了，假如用MyThread创建线程时，还指定了线程函数target=某个函数f
那么线程start的时候是先执行run函数还是县执行线程函数f
哈哈，这种情况一般时不会出现的，一般会将函数f作为被调用的函数添加到run函数中

3.一个进程中至少有一个线程，并作为程序的入口，这个线程一般是我们的主线程。程序运行时，我们可以在主线程中启动其他的线程
一个进程至少有一个主线程，其他为工作线程

4.start和run方法的区别
start()启动一个子线程，线程名即为定义的name
run()方法并不是启动一个新线程，就是在主线程中调用了一个普通函数
thread=myThread(1,"mythrd",1)
thread.run()
thread.start()
thread继承了threading.Thread类，并且重写了run方法
第一句thread=myThread(1,"mythrd",1)创建线程并不会自动去调用run方法
第二句thread.run()只是一个函数调用，在主线程中调用了run方法，并没有启动新线程
第三局thread.start()启动了创建的线程，线程start()后会自动调用run方法

5.线程同步
多个线程对同一数据进行修改，需要进行同步
如何同步：Thread对象的Lock与Rlock，对于哪些一次只允许一个线程操作的数据，可将其放在acquire与release方法之间。
锁机制：锁定与未锁定两种状态。现在我们有两个线程，一个是set的修改操作，一个是print的打印操作。每当一个线程比如“set”要
访问共享数据的时候，必须先获得锁定。等待“set”执行完释放了该共享资源的锁后，其他线程才可访问。

6.Python的优先级队列
Python的队列是线程安全的，即队列都实现了锁原语，能直接在多线程中使用。
那么因为队列是线程安全的，则可以用队列来实现线程之间的同步
Python的Queue模块中提供了同步的，线程安全的队列类，包括FIFO先入先出队列，后入先出队列，和优先级队列。
Queue.join() 实际上意味着等到队列为空，再执行别的操作
如果一个线程或者函数在执行的过程中调用另一个线程，并且希望其完成操作后才能执行，可以调用线程的join函数。转化为顺序执行
setDaemon()方法：主线程退出时，需要子线程随主线程退出，则设置子线程的setDaemon()

Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号
队列线程的思想：首先创建一个全局共享的队列，队列中只存在有限个元素。并将所有数据逐条加入到队列中，并调用队列的join函数
进行等待。之后便可以开启若干线程，线程的任务就是不断的从队列中取数据处理即可。这里，多个线程因为访问的是队列，队列本来就
是线程安全的，为什么在代码中还会加同步锁呢？见test4_PriorityQueue.py文件
